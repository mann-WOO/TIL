# 배열 (Array)



## 버블 정렬(Bubble Sort)

> 원소를 두 개씩 비교하며 큰 수를 뒤로 보내 마지막 원소부터 하나씩 확정 짓는 방식





## 카운팅 정렬(Counting Sort)

> 정렬할 값이 양의 정수이고, 자료의 범위를 알고 있을 때 사용하는 정렬

> 각 인덱스에 해당하는 수의 개수를 세고, 뒤에서부터 해당 인덱스에 배치해주는 방식

- 시간 복잡도 O(n + k): n은 리스트 길이, k는 정수의 최대값
- 최대값이 적당히 작을 때 효과적이다.





## 완전 검색(Exhaustive Search)

> 모든 경우의 수를 나열하고 확인하는 방식, Brute-force, Generate-and-Test라고도 불림
>
> 일반적으로 경우의 수가 상대적으로 작을 때 유용함. 모든 경우 테스트 후 해법 도출

### 순열(Permutation)

> n! 다양한 방법으로 구할 수 있다.





## 탐욕(Greedy) 알고리즘

> 최적해를 구하는 데 사용되는 근시안적인 방법. 선택의 순간에 최적이라고 생각 되는 것을 택하며 진행해, 최종 해답에 도달.
>
> 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 구현하면 Greedy 접근이 된다.

### 탐욕 알고리즘 동작 과정

1. 현재 문제에서 최적의 해를 구해 부분해 집합에 추가한다.
2. 오류가 없는지 확인한다.
3. 현재의 풀이 방법이 모든 경우를 풀이하는 방법인지 확인하고, 풀이가 불가능 하다면 1로 돌아간다.



## 2차원 배열

### 배열 순회

- 2중 `for`문을 이용한 행 우선/ 열 우선 순회
- 지그재그 순회: 모듈러`%`를 이용해 홀,짝 행 교차

### 델타 이동

- 좌표평면에서의 이동
- 장기, 체스 기물의 이동



## 부분집합

### 부분집합의 수

- 하나의 원소를 넣는다/넣지 않는다의 여부를 결정
- 따라서, 2의 원소수 제곱 만큼의 부분집합을 만들 수 있다.

### 비트연산, 2진법

> 8-bit(8bits)는 1byte

- n자리의 2진수를 만들 수 있다면, 부분집합을 쉽게 구할 수 있다.

### 비트연산자를 이용한 부분집합 구하기

```python
def subsets(arr):
    # 부분집합들의 리스트 result
    result = []
    for i in range(1 << len(arr)):
        # 부분집합을 담을 임시변수 tmp
        tmp = []
        for j in range(len(arr)):
            if i & (1 << j):
                tmp.append(arr[j])
        result.append(tmp)
    return result

print(subsets([1, 2, 3, 4, 5]))
```

- 첫 번째 for문의 i는 `0`부터 `2^(len(arr))-1`의 값을 **2진수**로 가지고 있다. 즉 i는 모든 부분집합의 경우의 수를 2진수로 나타낸 것이다. -> 0, 10, 11, 100, 101, 110, 111
- `1 << j`는 2진수에서 각 원소의 자리(위치)를 나타낸 것이다. -> (00)1, (0)10, 100
- i에서 부분집합의 구성이 완성되면, j에서 각 자리를 모두 대입하여 부분집합에 포함된 원소를 부분집합 `tmp`에 추가해주는 원리이다.
- 직접 3~4개의 원소를 가진 리스트의 i와 j를 적어보면 이해할 수 있다.



## 비트 연산

### 비트 연산자

- `&`: 두 비트 열을 비교해 두 비트 모두 1일 때 1
- `|`: 두 비트 열을 비교해 두 비트 중 하나라도 1일 때 1
- `<<`: 비트 열의 모든 비트를 왼쪽으로 한칸 씩 이동시킨다.
- `>>`: 비트 열의 모든 비트를 오른쪽으로 한칸 씩 이동시킨다.

### `<<`연산자의 활용

- `1 << n` 은 2^n를 의미한다. 따라서 부분집합을 구하는 데에 이용할 수 있다.



## 검색(Search)

### 순차검색

> n의 시간복잡도를 가진다.

- 정렬되지 않은 경우

> 하나씩 비교하며, 원하는 원소를 찾거나(True) 끝까지 검색해도 찾지 못한 경우(False) 종료

- 정렬된 경우

> 하나씩 비교하며, 원하는 원소를 찾거나(True) 원하는 원소보다 큰 값이 나오기 시작하면(False) 종료

### 이진검색

- 반씩 범위를 줄여가는 검색(un&down 게임)
- O(logn)의 시간복잡도
  - n개의 원소를 가진 리스트를 이진검색 할 때, **최악**의 경우 전체를 2로 나누며 1이 될때까지 x번 검색을 시행한다. 반대로 생각하면, 2를 x번 곱하면 n이 된다. 즉 `2^x = n`이고, 이는 `x = logn`과 같으므로 logn의 시간 복잡도를 가진다.



## 셀렉션 알고리즘(Selection Algorithm)

> k번째로 큰, 혹은 작은 원소를 찾는 알고리즘

### k번째로 작은 원소를 찾는 알고리즘

- 가장 작은 원소부터 k번째 작은 원소까지 하나씩 찾아 배열의 앞쪽으로 이동시켜 정렬
  - range(0, N)에서 최솟값을 arr[0]과 스왑, range(1, N)에서 최솟값을 arr[1]과 스왑.. 반복
- 배열의 k번째를 반환
- O(kn)의 수행시간이 필요함
  - 최악의 경우, 원소 하나의 위치를 바꿔주는 데에 n번의 작업을 수행해야하기 때문
  - 해당 작업을 k번 수행하면 kn



